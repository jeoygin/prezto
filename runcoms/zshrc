#
# Executes commands at the start of an interactive session.
#
# Authors:
#   Jeoygin Wang <jeoygin@gmail.com>
#

# Source Prezto.
if [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]]; then
  source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"
fi

# Source zplug
if [[ -s "${ZPLUG_HOME:-$HOME/.zplug}/init.zsh" ]]; then
  source "${ZPLUG_HOME:-$HOME/.zplug}/init.zsh"

  # k is a Zsh script to make directory listings more readable, adding Git status, fileweight colors and rotting dates
  # zplug "supercrabtree/k"
  
  # Jump back to a specific directory, without doing `cd ../../..`
  zplug "Tarrasch/zsh-bd"
  
  # A next-generation cd command with an interactive filter
  zplug "b4b4r07/enhancd", use:init.sh
  
  # Install plugins if there are plugins that have not been installed
  if ! zplug check --verbose; then
      printf "Install? [y/N]: "
      if read -q; then
          echo; zplug install
      fi
  fi
  
  if zplug check Tarrasch/zsh-bd; then
      . ~/.zplug/repos/Tarrasch/zsh-bd/bd.zsh
  fi
  
  if zplug check b4b4r07/enhancd; then
      export ENHANCD_FILTER=fzf-tmux
      . ~/.zplug/repos/b4b4r07/enhancd/init.sh
  fi
  
  # Then, source plugins and add commands to $PATH
  # zplug load
fi

# Customize to your needs...
setopt CORRECT
setopt CLOBBER

source ~/.zalias

compdef _tmux tmux.sh

function activate-python() {
  export WORKON_HOME=$HOME/.virtualenvs
  if [[ -x /usr/local/bin/virtualenvwrapper.sh ]]; then
    source /usr/local/bin/virtualenvwrapper.sh
  elif [[ -x /usr/bin/virtualenvwrapper.sh ]]; then
    source /usr/bin/virtualenvwrapper.sh
  else
    source ~/local/bin/virtualenvwrapper.sh
  fi
  workon python27
}
function activate-rvm() {
  [[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*
}
function activate-desk() {
  # Hook for desk activation
  [ -n "$DESK_ENV" ] && source "$DESK_ENV" || true
}
function activate-nvm() {
  export NVM_DIR="$HOME/.nvm"
  [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"  # This loads nvm
  [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
}
function activate-sdk() {
  #THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!!
  export SDKMAN_DIR="$HOME/.sdkman"
  [[ -s "$HOME/.sdkman/bin/sdkman-init.sh" ]] && source "$HOME/.sdkman/bin/sdkman-init.sh"
}
function activate-desk() {
  # Hook for desk activation
  [ -n "$DESK_ENV" ] && source "$DESK_ENV"
}
function activate-antigen() {
  [[ -s "${HOME}/local/bin/antigen.zsh" ]] && source "${HOME}/local/bin/antigen.zsh"
}
funciton activate-fuck() {
  eval "$(thefuck --alias)"
}
function find-image() {
  [ $# -lt 1 ] && echo "find-image <DIR>" && return -1
  find "$@" -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png'
}
function shufn() {
  local nb="${1:-1}"
  shuf | head -n "$nb"
}
function random-string() {
  cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w ${1:-16} | head -n 1
}
function random-number() {
  cat /dev/urandom | tr -dc '0-9' | fold -w ${1:-16} | head -n 1
}
function download_and_extract() {
  local usage="Usage: download_and_extract URL DIR"
  local url="${1:?${usage}}"
  local dir="${2:?${usage}}"
  echo "downloading ${url}" >&2
  mkdir -p "${dir}"
  curl -Ls "${url}" | tar -C "${dir}" --strip-components=1 -xz
}
function pack() {
  local usage="Usage: pack FILES"
  local pack="${1:?${usage}}.tar.gz"
  if [[ $# -gt 1 ]]; then
    pack="pack.tar.gz"
  fi
  echo "packing $@ => $pack" >&2
  tar zcf "$pack" "$@"
}
function packup() {
  [ $# -lt 1 ] && echo "Usage: packup FILES" && return -1
  echo "archiving and uploading $@" >&2
  tar zc "$@" | mupload -o "pack-$( random-string 8 ).tar.gz" -f -
}
function packdown() {
  local usage="Usage: packdow TAR_URL"
  local url="${1:?${usage}}"
  echo "downloading $url" >&2
  curl -L --progress-bar "$1" | tar zx
}
function sample() {
  _n=${1:-10}
  shuf | head -n ${_n}
}
function imgtk-ls() {
  [ $# -lt 1 ] && echo "imgtk-ls <DB>" && return -1
  imgtk -s "$1" -c list
}
function imgtk-save() {
  [ $# -lt 2 ] && echo "imgtk-ls <SRC DB> <DST DB>" && return -1
  imgtk -s "$1" -d "$2" -c save
}
function imgtk-cat() {
  [ $# -lt 1 ] && echo "imgtk-ls <DB>" && return -1
  imgtk -s "$1" -c cat
}
function imgtk-1c() {
  awk '{print $1}' "$@"
}
function imgtk-2c() {
  awk '{print $1"::"$1}' "$@"
}

function fuzzy-finder() {
  declare -a _options
  if [[ $# -gt 0 ]]; then
    _options=( $_options "-q \"$@\"" )
  fi
  eval ${FUZZY_FINDER:-fzf-tmux} "${_options[@]}"
}

function ppgrep() {
    ps aux | fuzzy-finder "$@" | awk '{ print $2 }'
}

function ppkill() {
  if [[ $1 =~ "^-" ]]; then
    QUERY=""            # options only
  else
    QUERY=$1            # with a query
    [[ $# > 0 ]] && shift
  fi
  ppgrep $QUERY | xargs kill $*
}

function find-file() {
  declare -a _options
  if [[ -z "${NOT_FOLLOW:-}" ]]; then
    _options=( -L )
  fi
  declare -a _exps
  if [[ -z "${SHOW_HIDDEN_FILES:-}" ]]; then
    _exps=( -not -path '*/\.*' )
  fi
  find "${_options[@]}" "${1:-.}" -type "${FILE_TYPE:-f}" \
    -mindepth ${MINDEPTH:-1} -maxdepth ${MAXDEPTH:-1} \
    "${_exps[@]}"
}

function ls-file() {
  find-file "$@" | xargs -I{} basename {}
}

function ls-dir() {
  FILE_TYPE=d find-file "$@" | xargs -I{} basename {}
}

function ls-link() {
  FILE_TYPE=l find-file "$@" | xargs -I{} basename {}
}

function cdsd() {
  local _dir="."
  if [[ $# -gt 0 ]]; then
    _dir="$1"
    shift
  fi
  local _sub_dir=$( ls-dir "$_dir" 2>/dev/null | fuzzy-finder "$@")
  if [[ -n "$_sub_dir" ]]; then
    cd "$_dir/$_sub_dir"
  fi
}

function cdp() {
  cdsd "${PROJECTS_ROOT:-$HOME/projects}" "$@"
}

function cdpp() {
  cdsd "${PERSONAL_PROJECTS_ROOT:-$HOME/projects/personal}" "$@"
}

function fff() {
  declare -a _options
  _options=( --bind "$FZF_PREVIEW_BINDING" )
  _options=( $_options --preview-window right:70% )
  _options=( $_options --preview "head -$LINES {}" --tac )
  if [[ $# -gt 0 ]]; then
    _options=( $_options -q "$@" )
  fi
  local _file=$( ls-file | fzf "${_options[@]}")
  if [[ -n "$_file" ]]; then
    less "$_file"
  fi
}

[[ -s "${HOME}/.zcustom" ]] && source "${HOME}/.zcustom"

fpath=(
  ~/.zsh/completion
  $fpath
)

autoload -U compinit && compinit -u
